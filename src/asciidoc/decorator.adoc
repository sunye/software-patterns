:revealjs_center: false
:revealjs_display: flex
:revealjs_transition: none
:revealjs_slideNumber: c/t
:revealjs_theme: stereopticon
:revealjs_width: 1920
:revealjs_height: 1080
:revealjs_history: true
:revealjs_margin: 0
:source-highlighter: highlightjs
:imagesdir: images
:includedir: includes
:sectids!:

= Decorator

Gamma et al. 95

'''

== Intent

* Dynamically add a behavior to an object.
* Propose a flexible alternative to inheritance.

note:

Attach additional responsibilities to an object dynamically.
Decorators provide a flexible alternative to subclassing for extending functionality 

'''

== Motivation

* Occasionally, we want to add a behavior only to certain objects of a class.

image::decorator-example.png[align=center]

[Gamma 95]

'''

== Motivation - Example (1/2)

image::decorator-classes.png[align=center]

'''

== Motivation - Example (2/2)

image::decorator-instances.png[align=center]

'''

== Applicability (1/2)

* Use the decorator pattern when you want to:
* add a behavior to an object dynamically and transparently.
* add a behavior that can be removed later.

note:
to add responsibilities to individual objects dynamically and transparently, that is, without affecting other objects.
for responsibilities that can be withdrawn. 

'''

== Applicability (2/2)

* Use the decorator pattern when the creation of subclasses is impractical.

note:
Sometimes a large number of independent extensions are possible and would produce an explosion of subclasses to support every combination. +
Or a class definition may be hidden or otherwise unavailable for subclassing. 

'''

== Structure

image::decorator-structure.png[align=center]

* */Component*: the object we want to add behavior to
* */Decorator*: the object that adds behavior to the component.
'''

== Consequences

* More flexible than inheritance.
* Prevents the creation of complex/heavy classes on the top of a class hierarchy.
* Components and decorators are not identical: comparison may not work as expected.
* Explosion of small objects.

note:
- more flexible: one can add twice the same behavior!!!
- Component classes REMAIN small.

'''

== Implementation Tradeoffs

* Interface conformance: components and decorators must implement the same interface.
* Omission of the abstract Decorator class.
* Lightweight component classes: since decorators specialize the component, the latter should have the less properties as possible.
'''

== Authors and Date

* «Design Patterns: Elements of Reusable Object-Oriented Software.» Erich Gamma, Richard Helm,Ralph Johnson, and John Vlissides. Addison Wesley. October 1994.
'''

== More Examples

'''

== Starbuzz Coffee

image::patterns/starbuzz-problem.jpg[]

[Bates et al. 2009]

'''

image::patterns/starbuzz-class-explosion.png[align=center]

[Bates et al. 2009]

'''

image::patterns/starbuzz-decorator.png[align=center]

[Bates et al. 2009]

—-

== Java I/O

image::patterns/java-input-stream.png[align=center]

[source,java]
----
InputStream is = new FileInputStream(file);
DataInputStream dis = new DataInputStream(is);
BufferedInputStream bis = new BufferedInputStream(dis);

----

'''

=== FilterInputStream.java

[source,java]
----
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
	
    protected FilterInputStream(InputStream in) {
        this.in = in;
    }
	
    public int read() throws IOException {
        return in.read();
    }
	
	//(...)

----

'''

== Java Collections Framework

image::patterns/java-list.png[align=center]

[source,java]
----
List<String> tags = new ArrayList();
List<String> synchronizedTags = Collections.synchronizedList(tags);
List<String> readOnlyTags = Collections.unmodifiableList(tags);

----

'''
